#import "@preview/mmdr:0.1.0":  mermaid

#import "@preview/oxdraw:0.1.0": *
#set heading(numbering: "1.")
= Разработка программы
== Проектирование структуры программы
// #figure(kind: "Схема", supplement: "Схема", caption: "Диаграмма классов", image("/assets/mermaid-diagram-2025-12-23-140952.png"))
#figure(supplement: "Схема", kind: "Схема", caption: "Диаграмма классов", mermaid(raw(read("classDiagram.md"))) )

// #mermaid("graph TD; A --> B;")
=== Проектирование структуры программы

Разрабатываемое приложение ExpirySpy реализовано как консольное приложение на платформе .NET и использует СУБД SQLite для хранения данных. Структура программы построена по модульному принципу и логически разделена на несколько уровней: уровень пользовательского интерфейса (консольное меню), уровень предметной области (модели данных), уровень доступа к данным (репозиторий) и модуль инициализации базы данных.

==== Общая архитектура

- **Уровень пользовательского интерфейса**:  
  Представлен основным модулем `Program`, в котором реализована логика запуска приложения, формирование главного меню и обработка пользовательских команд. На этом уровне осуществляется вывод сводной информации о ресурсах и категориях, работа с деревом категорий, добавление, изменение и удаление записей.

- **Уровень моделей предметной области**:  
  Представлен классами `ResourceCategory`, `ResourceItem` и перечислением `ResourceState` (файл `Models.cs`). Эти сущности описывают основные объекты предметной области: категории ресурсов, отдельные ресурсные единицы и их состояние по сроку годности.

- **Уровень доступа к данным**:  
  Реализован классом `Repository` (файл `Repository.cs`), который инкапсулирует всю работу с базой данных SQLite: выполнение SQL‑запросов, преобразование строк таблиц в объекты моделей и обратно. Модуль выступает единым интерфейсом к данным для остальных частей программы.

- **Модуль управления базой данных**:  
  Представлен статическим классом `Database` (файл `Database.cs`), который отвечает за формирование строки подключения и создание структуры таблиц при первом запуске программы.

==== Описание основных модулей программы

- **Модуль `Program` (файл `Program.cs`)**:  
  - **Назначение**: организация взаимодействия пользователя с системой через консольный интерфейс.  
  - **Функциональность**:  
    - инициализация базы данных (`Database.EnsureCreated()`);  
    - создание экземпляра репозитория (`Repository`) и начальное заполнение справочников (`SeedCategoriesIfEmpty`, `SeedSampleResourcesIfEmpty`, нормализация наименований категорий);  
    - вывод сводной информации о состоянии ресурсов и категорий (`ShowOverview`);  
    - управление главным меню и обработка пользовательского ввода (`RunMainMenu`);  
    - операции с категориями: просмотр дерева категорий (`ShowCategories`), добавление новой категории (`AddCategory`), удаление категории (`DeleteCategory`);  
    - операции с ресурсами: вывод всех ресурсов и ресурсов в разрезе категорий (`ShowResources`), вывод просроченных и «скоро истекающих» ресурсов (`ShowResourcesByState`), поиск ресурсов с недостаточным остатком (`ShowLowOnStock`), добавление ресурса (`AddResource`), изменение количества (`ChangeResourceQuantity`), удаление ресурса (`DeleteResource`);  
    - вспомогательные функции для форматированного вывода таблиц и обработки строк (`PrintResourceTable`, `Truncate`, `NormalizeUnit`, `Pause`).  
  - **Представление в программе**: статические методы верхнего уровня в файле `Program.cs`, использующие модуль `Repository` как основной источник данных.

- **Модуль моделей предметной области (файл `Models.cs`)**:  
  - **Класс `ResourceCategory`**:  
    - **Назначение**: представление категории ресурсов (например, «Еда», «Медикаменты», «Одежда») и подкатегорий.  
    - **Основные поля**: идентификатор `Id`, наименование `Name`, ссылка на родительскую категорию `ParentId`, а также значения по умолчанию для создаваемых ресурсов (`DefaultQuantity`, `DefaultUnit`, `DefaultMinQuantity`).  
    - **Роль в системе**: позволяет выстраивать иерархическое дерево категорий и задавать типовые значения по умолчанию, упрощающие ввод данных.  
  - **Класс `ResourceItem`**:  
    - **Назначение**: представление отдельной записи о ресурсе (конкретная партия товара с датой покупки, сроком годности и количеством).  
    - **Основные поля**: `Id`, `CategoryId`, `Name`, `PurchaseDate`, `ExpiryDate`, `Quantity`, `Unit`, `MinQuantity`.  
    - **Методы**:  
      - `GetState(DateTime now)` — вычисляет состояние ресурса по отношению к текущей дате (просрочен, скоро истекает, доступен);  
      - `IsLowOnStock()` — определяет, является ли остаток меньше либо равным минимальному допустимому количеству.  
    - **Роль в системе**: служит основной единицей учета, по которой выполняется анализ состояния запасов и сроков годности.  
  - **Перечисление `ResourceState`**:  
    - **Назначение**: формализует возможные состояния ресурса по сроку годности (`Expired`, `ExpiringSoon`, `Available`), что упрощает фильтрацию и отображение данных.

- **Модуль работы с базой данных `Database` (файл `Database.cs`)**:  
  - **Назначение**: централизованное управление параметрами подключения к базе данных и инициализация её структуры.  
  - **Функциональность**:  
    - `GetConnectionString()` — формирует строку подключения к файлу базы `expiryspy.db`;  
    - `EnsureCreated()` — при запуске приложения проверяет наличие таблиц `Categories` и `Resources` и создаёт их при отсутствии, используя SQL‑команды `CREATE TABLE IF NOT EXISTS`.  
  - **Роль в системе**: скрывает детали работы с SQLite и обеспечивает готовность хранилища данных до того, как к нему начнёт обращаться репозиторий.

- **Модуль доступа к данным `Repository` (файл `Repository.cs`)**:  
  - **Назначение**: реализация шаблона «репозиторий» для работы с таблицами `Categories` и `Resources`. Обеспечивает унифицированный интерфейс для операций чтения и изменения данных.  
  - **Функциональность**:  
    - операции с категориями: добавление (`AddCategory`), получение списка (`GetAllCategories`), выбор одной категории по идентификатору (`GetCategoryById`), изменение наименования (`UpdateCategoryName`), удаление (`DeleteCategory`);  
    - операции с ресурсами: добавление (`AddResource`), получение всех ресурсов (`GetAllResources`), получение ресурсов совместно с именами категорий (`GetResourcesWithCategories`), выбор ресурсов по состоянию (`GetResourcesByState`), поиск ресурсов с недостаточным остатком (`GetLowOnStockResources`), изменение количества (`UpdateResourceQuantity`), удаление (`DeleteResource`);  
    - вспомогательный метод `ReadResource` для преобразования строки результата SQL‑запроса в объект `ResourceItem`.  
  - **Роль в системе**: изолирует уровень пользовательского интерфейса от подробностей SQL‑запросов и формата хранения данных, обеспечивая более простую и безопасную работу с базой.

==== Взаимосвязи модулей

Логика взаимодействия модулей имеет иерархический характер:

- **Модуль `Program`** является «точкой входа» приложения и использует `Database` для первичной инициализации структуры базы данных, а затем создаёт объект `Repository` на основе строки подключения. Все дальнейшие операции с данными выполняются через методы `Repository`.
- **Модуль `Repository`** опирается на объекты моделей `ResourceCategory` и `ResourceItem` при чтении и сохранении данных, заполняя их из результатов SQL‑запросов и, наоборот, используя их поля для формирования запросов.
- **Класс `ResourceItem`** логически связан с `ResourceCategory` через поле `CategoryId`, а для определения состояния ресурса использует перечисление `ResourceState`. Таким образом, состояние каждого ресурса вычисляется на уровне предметной области, а не на уровне базы данных.
- **Модуль `Database`** не знает о моделях и репозитории, его задача ограничивается созданием таблиц и предоставлением строки подключения, что упрощает сопровождение кода и делает модуль переиспользуемым.

Структура программы и связи между основными классами дополнительно отображены на диаграмме классов (см. диаграмму структуры программы в приложении), где показаны зависимости между модулями `Database`, `Repository`, `ResourceCategory`, `ResourceItem` и перечислением `ResourceState`. Эта диаграмма наглядно демонстрирует, что модуль пользовательского интерфейса обращается только к репозиторию и моделям, а все низкоуровневые детали работы с базой данных инкапсулируются в отдельных компонентах.
== ывывывыв
=== 3.2 Описание данных и структур данных

==== 3.2.1 Хранение информации об основном объекте программы

Основным объектом программы являются **учитываемые ресурсы** (товары, медикаменты, одежда и т. п.), сгруппированные по **категориям**. Для представления данных в программе используются два класса‑модели:

- **`ResourceCategory`** – представляет категорию ресурсов:  
  - `Id : long` – уникальный идентификатор категории;  
  - `Name : string` – наименование категории;  
  - `ParentId : long?` – идентификатор родительской категории (для корневых категорий `null`), что позволяет строить иерархическое дерево;  
  - `DefaultQuantity : double?` – количество по умолчанию для создаваемых в этой категории ресурсов;  
  - `DefaultUnit : string?` – единица измерения по умолчанию;  
  - `DefaultMinQuantity : double?` – минимальное количество по умолчанию (порог «малого остатка»).  

- **`ResourceItem`** – представляет конкретный ресурс:  
  - `Id : long` – уникальный идентификатор ресурса;  
  - `CategoryId : long` – ссылка на категорию (`ResourceCategory`), к которой относится ресурс;  
  - `Name : string` – наименование ресурса;  
  - `PurchaseDate : DateTime` – дата покупки;  
  - `ExpiryDate : DateTime` – дата истечения срока годности;  
  - `Quantity : double` – текущее количество ресурса;  
  - `Unit : string` – единица измерения (шт, кг, л и т. д.);  
  - `MinQuantity : double` – минимально допустимое количество (ниже этого значения ресурс считается «с малым остатком»).  

Дополнительно используется перечисление **`ResourceState`** (`Expired`, `ExpiringSoon`, `Available`), которое задаёт дискретное множество состояний ресурса по сроку годности. Метод `GetState(DateTime now)` класса `ResourceItem` вычисляет текущее состояние на основании разницы между текущей датой и `ExpiryDate`, а метод `IsLowOnStock()` определяет, не является ли остаток меньше либо равным `MinQuantity`.

Физически данные об основных объектах хранятся в базе данных SQLite в двух таблицах:

- **`Categories`**  
  - `Id INTEGER PRIMARY KEY AUTOINCREMENT`  
  - `Name TEXT NOT NULL`  
  - `ParentId INTEGER NULL` (внешний ключ на `Categories.Id`)  
  - `DefaultQuantity REAL NULL`  
  - `DefaultUnit TEXT NULL`  
  - `DefaultMinQuantity REAL NULL`  

- **`Resources`**  
  - `Id INTEGER PRIMARY KEY AUTOINCREMENT`  
  - `CategoryId INTEGER NOT NULL` (внешний ключ на `Categories.Id`)  
  - `Name TEXT NOT NULL`  
  - `PurchaseDate TEXT NOT NULL` (дата в формате `yyyy-MM-dd`)  
  - `ExpiryDate TEXT NOT NULL` (дата в формате `yyyy-MM-dd`)  
  - `Quantity REAL NOT NULL`  
  - `Unit TEXT NOT NULL`  
  - `MinQuantity REAL NOT NULL`  

Таким образом, на логическом уровне данные представлены объектами классов `ResourceCategory` и `ResourceItem`, а на физическом уровне — записями в таблицах `Categories` и `Resources`, связанными через поле `CategoryId`. Доступ к этим данным инкапсулирован в классе `Repository`, который выполняет преобразование между строками таблиц и объектами моделей.

==== 3.2.2 Данные, вводимые пользователем, и проверки (словарь данных)

При работе программы пользователь вводит данные через консольный интерфейс. Ниже приведён «словарь данных» с указанием формата ввода и проверок.

- **Пункт главного меню**  
  - Источник: `RunMainMenu`, ввод одной цифры (`Console.ReadLine`).  
  - Формат: строка, ожидаются значения `"0"`–`"10"`.  
  - Проверка: при несоответствии доступным пунктам выводится сообщение «Неизвестная команда», повтор меню.

- **Создание категории (`AddCategory`)**  
  - `Название категории`  
    - Тип (логический): строка (`string`).  
    - Формат: произвольный непустой текст.  
    - Проверки: `string.IsNullOrWhiteSpace(name)` – пустое или пробельное значение отвергается, выводится «Название обязательно».  
  - `Id родительской категории`  
    - Тип (логический): целое (`long?`).  
    - Формат: целое число или пустая строка (если нет родителя).  
    - Проверки: `long.TryParse`; при пустой строке значение считается `null`. При некорректном числе – ввод интерпретируется как отсутствие родителя.  
  - `Количество по умолчанию`  
    - Тип (логический): вещественное число (`double?`).  
    - Формат: число или пустая строка.  
    - Проверки: `double.TryParse`; при пустой строке значение `null`. При некорректном вводе — параметр не задаётся.  
  - `Единица измерения по умолчанию`  
    - Тип: строка (`string?`).  
    - Формат: произвольная строка или пусто.  
    - Проверки: пустая строка записывается как `null`.  
  - `Минимальное количество по умолчанию`  
    - Тип: вещественное (`double?`).  
    - Формат и проверки аналогичны полю «Количество по умолчанию».

- **Создание ресурса (`AddResource`)**  
  - `Id категории`  
    - Тип: целое (`long`).  
    - Формат: целое число.  
    - Проверки: `long.TryParse`, а также проверка, что среди загруженных категорий существует категория с таким `Id`. При неверном вводе — сообщение «Неверная категория» и отмена операции.  
  - `Название ресурса`  
    - Тип: строка (`string`).  
    - Проверка: `string.IsNullOrWhiteSpace(name)` – при пустом значении выводится «Название обязательно», операция прерывается.  
  - `Дата покупки`  
    - Тип (логический): дата (`DateTime`).  
    - Формат: `yyyy-MM-dd`.  
    - Особенность: при пустом вводе используется значение по умолчанию — текущая дата (`DateTime.Now.Date`).  
    - Проверки: `DateTime.TryParse`; при неверном формате выводится «Неверный формат даты», операция прерывается.  
  - `Срок годности`  
    - Тип: дата (`DateTime`).  
    - Формат: `yyyy-MM-dd`.  
    - Проверки: `DateTime.TryParse`; при ошибке — сообщение «Неверный формат даты» и прекращение ввода.  
  - `Количество`  
    - Тип: вещественное (`double`).  
    - Формат: число.  
    - Значение по умолчанию: если поле оставлено пустым, берётся `DefaultQuantity` у выбранной категории или `1`.  
    - Проверки: `double.TryParse`; при неверном вводе — «Неверное количество».  
  - `Единицы измерения`  
    - Тип: строка (`string`).  
    - Значение по умолчанию: `DefaultUnit` категории или `"шт"`.  
    - Проверки: строка обрезается методом `NormalizeUnit` (удаление лишних пробелов).  
  - `Минимальное количество`  
    - Тип: вещественное (`double`).  
    - Значение по умолчанию: `DefaultMinQuantity` категории или `1`.  
    - Проверки: `double.TryParse`; при ошибке — «Неверное количество».

- **Изменение количества ресурса (`ChangeResourceQuantity`)**  
  - `ID ресурса`  
    - Тип: целое (`long`).  
    - Формат: целое число.  
    - Проверки: `long.TryParse`; затем поиск ресурса в списке. При отсутствии — сообщение «Ресурс с таким ID не найден».  
  - `Новое количество`  
    - Тип: вещественное (`double`).  
    - Формат: число.  
    - Проверки: `double.TryParse`; при неверном вводе — «Неверное количество».

- **Удаление ресурса (`DeleteResource`)**  
  - `ID ресурса` – аналогично изменению количества.  
  - `Подтверждение`  
    - Тип: строка.  
    - Формат: ожидается `y`/`Y` для подтверждения.  
    - Проверка: сравнение `string.Equals(confirm, "y", StringComparison.OrdinalIgnoreCase)`; при любом другом вводе — «Удаление отменено».

- **Удаление категории (`DeleteCategory`)**  
  - `ID категории`  
    - Тип: целое (`long`).  
    - Проверка: `long.TryParse` и поиск категории. При неверном ID — «Категория с таким ID не найдена».  
  - Дополнительные проверки целостности:  
    - наличие подкатегорий (`hasChildren`),  
    - наличие привязанных ресурсов (`directCount > 0`).  
    - Если есть подкатегории или ресурсы — выводится сообщение о невозможности удаления и требовании предварительно удалить подкатегории и/или ресурсы.  
  - `Подтверждение` – аналогично подтверждению удаления ресурса.

Особенности данных, влияющие на интерфейс:

- Все проверки вводимых данных выполняются **на стороне программы** перед записью в базу, что предотвращает появление некорректных записей (пустые названия, неправильный формат дат, несуществующие категории, некорректные числовые значения).
- Для удобства пользователя используются **значения по умолчанию**, зависящие от выбранной категории (количество, единицы измерения, минимальное количество) и текущей даты (дата покупки).
- Вывод структурированных таблиц (ресурсы, категории, сводка по состоянию) реализован в виде текстовых табличных представлений, где данные форматируются по ширине столбцов; это накладывает ограничения на длину строк (метод `Truncate` обрезает слишком длинные значения с добавлением многоточия).

==== 3.2.3 Описание используемых файлов

В процессе работы программы используются как **исполняемые файлы**, так и **файлы данных**. С точки зрения хранения и обмена данных основным является файл базы данных.

- **Файл базы данных `expiryspy.db`**  
  - Тип: файл SQLite.  
  - Содержимое: таблицы `Categories` и `Resources`, описанные выше.  
  - Назначение: долговременное хранение информации о категориях и ресурсах между запусками программы.  
  - Формат хранения дат: текстовый формат `yyyy-MM-dd`, используемый при чтении/записи в коде репозитория.  
  - Доступ: файл создаётся и инициализируется модулем `Database` при первом запуске (`EnsureCreated`), последующие операции чтения/записи выполняются через класс `Repository`.

- **Исполняемые и служебные файлы (.exe, .dll, .json)**  
  - Файлы `ExpirySpy.exe`, `ExpirySpy.dll`, конфигурационные файлы платформы и библиотек (`*.runtimeconfig.json`, `Microsoft.Data.Sqlite.dll`, `SQLitePCLRaw.*.dll`) обеспечивают выполнение программы и работу с SQLite, но **не используются непосредственно для хранения предметных данных**.  
  - Они не изменяются в процессе работы приложения и не участвуют в передаче данных пользователю.

- **Файлы исходного кода и документации (`Program.cs`, `Models.cs`, `Repository.cs`, `Database.cs`, `diagram.md`)**  
  - Представляют собой текстовые файлы с описанием логики работы программы, структур данных и диаграммой классов.  
  - Используются на этапе разработки и сопровождения, но не участвуют в рабочем процессе как носители изменяемых пользовательских данных.

Передача данных между компонентами программы осуществляется в виде **объектов классов `ResourceCategory` и `ResourceItem`**, которые создаются на основе данных из файла `expiryspy.db` и, в свою очередь, при изменении записываются обратно через модуль `Repository`. Взаимодействие с внешними по отношению к программе устройствами сводится к работе с **консолью** (устройства ввода/вывода): пользователь вводит данные с клавиатуры, а программа выводит табличные отчёты, подсчёты и сообщения об ошибках в текстовом виде.
Анализирую код и выделяю основные алгоритмы для раздела 3.3. Изучаю ключевые функции программы:


Раздел 3.3 с описанием основных алгоритмов и блок-схемами на Mermaid:

=== 3.3 Разработка алгоритмов

В программе используются алгоритмы для работы с данными, определения состояния ресурсов, формирования отчётов и управления пользовательским интерфейсом. Ниже описаны основные алгоритмы.

==== 3.3.1 Алгоритм главного цикла программы

Главный цикл обеспечивает непрерывную работу приложения и обработку команд пользователя. Алгоритм реализует паттерн «цикл меню» с бесконечным циклом до выбора команды выхода.

**Блок-схема алгоритма главного цикла:**

```mermaid
flowchart TD
    Start([Начало]) --> Init[Очистка экрана]
    Init --> ShowOverview[Вывод сводной информации]
    ShowOverview --> ShowMenu[Вывод меню действий]
    ShowMenu --> ReadInput[Ввод команды пользователя]
    ReadInput --> Check{Команда = '0'?}
    Check -->|Да| End([Выход из программы])
    Check -->|Нет| Switch{Выбор команды}
    Switch -->|'1'| ShowCat[Показать дерево категорий]
    Switch -->|'2'| ShowRes[Показать все ресурсы]
    Switch -->|'3'| ShowExpSoon[Показать ресурсы с истекающим сроком]
    Switch -->|'4'| ShowExpired[Показать просроченные ресурсы]
    Switch -->|'5'| ShowLow[Показать ресурсы с малым остатком]
    Switch -->|'6'| ChangeQty[Изменить количество ресурса]
    Switch -->|'7'| AddCat[Добавить категорию]
    Switch -->|'8'| AddRes[Добавить ресурс]
    Switch -->|'9'| DelRes[Удалить ресурс]
    Switch -->|'10'| DelCat[Удалить категорию]
    Switch -->|Другое| Error[Вывод: 'Неизвестная команда']
    ShowCat --> Pause1[Пауза]
    ShowRes --> Pause2[Пауза]
    ShowExpSoon --> Pause3[Пауза]
    ShowExpired --> Pause4[Пауза]
    ShowLow --> Pause5[Пауза]
    ChangeQty --> Pause6[Пауза]
    AddCat --> Pause7[Пауза]
    AddRes --> Pause8[Пауза]
    DelRes --> Pause9[Пауза]
    DelCat --> Pause10[Пауза]
    Error --> Pause11[Пауза]
    Pause1 --> Init
    Pause2 --> Init
    Pause3 --> Init
    Pause4 --> Init
    Pause5 --> Init
    Pause6 --> Init
    Pause7 --> Init
    Pause8 --> Init
    Pause9 --> Init
    Pause10 --> Init
    Pause11 --> Init
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ГлавныйЦиклМеню
НАЧАЛО
    ПОКА ИСТИНА ВЫПОЛНЯТЬ
        ОчиститьЭкран()
        ПоказатьСводку()
        ВывестиМеню()
        Ввод := ПрочитатьСтроку()
        ЕСЛИ Ввод = "0" ТО
            ВЫХОД
        КОНЕЦ ЕСЛИ
        ВЫБОР Ввод
            СЛУЧАЙ "1": ПоказатьКатегории()
            СЛУЧАЙ "2": ПоказатьРесурсы()
            СЛУЧАЙ "3": ПоказатьРесурсыПоСостоянию(СкороИстекает)
            СЛУЧАЙ "4": ПоказатьРесурсыПоСостоянию(Просрочен)
            СЛУЧАЙ "5": ПоказатьРесурсыСМалымОстатком()
            СЛУЧАЙ "6": ИзменитьКоличествоРесурса()
            СЛУЧАЙ "7": ДобавитьКатегорию()
            СЛУЧАЙ "8": ДобавитьРесурс()
            СЛУЧАЙ "9": УдалитьРесурс()
            СЛУЧАЙ "10": УдалитьКатегорию()
            ИНАЧЕ: Вывести("Неизвестная команда")
        КОНЕЦ ВЫБОР
        Пауза()
    КОНЕЦ ПОКА
КОНЕЦ
```

==== 3.3.2 Алгоритм определения состояния ресурса

Определяет состояние ресурса по сроку годности относительно текущей даты. Используется для фильтрации и отображения ресурсов.

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: GetState]) --> Input[Вход: ExpiryDate, now]
    Input --> Compare1{ExpiryDate.Date < now.Date?}
    Compare1 -->|Да| ReturnExpired[Вернуть Expired]
    Compare1 -->|Нет| CalcDays[daysLeft = ExpiryDate.Date - now.Date]
    CalcDays --> Compare2{daysLeft <= 7?}
    Compare2 -->|Да| ReturnSoon[Вернуть ExpiringSoon]
    Compare2 -->|Нет| ReturnAvailable[Вернуть Available]
    ReturnExpired --> End([Конец])
    ReturnSoon --> End
    ReturnAvailable --> End
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ОпределитьСостояниеРесурса
ВХОД: ExpiryDate (дата истечения), now (текущая дата)
ВЫХОД: ResourceState (состояние ресурса)
НАЧАЛО
    ЕСЛИ ExpiryDate.Date < now.Date ТО
        ВЕРНУТЬ Expired
    КОНЕЦ ЕСЛИ
    daysLeft := (ExpiryDate.Date - now.Date).TotalDays
    ЕСЛИ daysLeft <= 7 ТО
        ВЕРНУТЬ ExpiringSoon
    ИНАЧЕ
        ВЕРНУТЬ Available
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

==== 3.3.3 Алгоритм проверки малого остатка

Проверяет, является ли текущее количество ресурса меньше или равным минимально допустимому.

**Блок-схема алгоритма:**

```{mermaid}
flowchart TD
    Start([Начало: IsLowOnStock]) --> Input[Вход: Quantity, MinQuantity]
    Input --> Compare{Quantity <= MinQuantity?}
    Compare -->|Да| ReturnTrue[Вернуть ИСТИНА]
    Compare -->|Нет| ReturnFalse[Вернуть ЛОЖЬ]
    ReturnTrue --> End([Конец])
    ReturnFalse --> End
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ПроверитьМалыйОстаток
ВХОД: Quantity (текущее количество), MinQuantity (минимальное количество)
ВЫХОД: ЛОГИЧЕСКОЕ (истина, если остаток мал)
НАЧАЛО
    ЕСЛИ Quantity <= MinQuantity ТО
        ВЕРНУТЬ ИСТИНА
    ИНАЧЕ
        ВЕРНУТЬ ЛОЖЬ
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

==== 3.3.4 Алгоритм добавления ресурса

Реализует процесс ввода данных о новом ресурсе с валидацией и использованием значений по умолчанию из категории.

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: AddResource]) --> Clear[Очистить экран]
    Clear --> GetCategories[Получить все категории]
    GetCategories --> CheckCat{Категорий > 0?}
    CheckCat -->|Нет| Error1[Вывести: 'Сначала создайте категорию']
    Error1 --> Pause1[Пауза]
    Pause1 --> End([Конец])
    CheckCat -->|Да| ShowCat[Вывести список категорий]
    ShowCat --> InputCatId[Ввести ID категории]
    InputCatId --> ValidateCat{ID корректен?}
    ValidateCat -->|Нет| Error2[Вывести: 'Неверная категория']
    Error2 --> Pause2[Пауза]
    Pause2 --> End
    ValidateCat -->|Да| GetCat[Получить категорию]
    GetCat --> InputName[Ввести название]
    InputName --> CheckName{Название пусто?}
    CheckName -->|Да| Error3[Вывести: 'Название обязательно']
    Error3 --> Pause3[Пауза]
    Pause3 --> End
    CheckName -->|Нет| InputPurchaseDate[Ввести дату покупки]
    InputPurchaseDate --> CheckDate1{Дата корректна?}
    CheckDate1 -->|Нет| Error4[Вывести: 'Неверный формат даты']
    Error4 --> Pause4[Пауза]
    Pause4 --> End
    CheckDate1 -->|Да| InputExpiryDate[Ввести срок годности]
    InputExpiryDate --> CheckDate2{Дата корректна?}
    CheckDate2 -->|Нет| Error5[Вывести: 'Неверный формат даты']
    Error5 --> Pause5[Пауза]
    Pause5 --> End
    CheckDate2 -->|Да| InputQuantity[Ввести количество]
    InputQuantity --> CheckQty{Количество корректно?}
    CheckQty -->|Нет| Error6[Вывести: 'Неверное количество']
    Error6 --> Pause6[Пауза]
    Pause6 --> End
    CheckQty -->|Да| InputUnit[Ввести единицы измерения]
    InputUnit --> InputMinQty[Ввести минимальное количество]
    InputMinQty --> CheckMinQty{Минимальное количество корректно?}
    CheckMinQty -->|Нет| Error7[Вывести: 'Неверное количество']
    Error7 --> Pause7[Пауза]
    Pause7 --> End
    CheckMinQty -->|Да| CreateItem[Создать объект ResourceItem]
    CreateItem --> SaveItem[Сохранить ресурс в БД]
    SaveItem --> Success[Вывести: 'Ресурс добавлен']
    Success --> Pause8[Пауза]
    Pause8 --> End
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ДобавитьРесурс
НАЧАЛО
    ОчиститьЭкран()
    категории := ПолучитьВсеКатегории()
    ЕСЛИ категории.Count = 0 ТО
        Вывести("Сначала создайте хотя бы одну категорию")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    ВывестиСписокКатегорий(категории)
    Ввод("Id категории: ")
    ЕСЛИ НЕ РаспарситьЦелое(Ввод) ИЛИ категория не найдена ТО
        Вывести("Неверная категория")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    категория := НайтиКатегорию(Id)
    Ввод("Название ресурса: ")
    ЕСЛИ СтрокаПуста(Ввод) ТО
        Вывести("Название обязательно")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    название := ОбрезатьПробелы(Ввод)
    Ввод("Дата покупки: ")
    ЕСЛИ СтрокаПуста(Ввод) ТО
        датаПокупки := Сегодня()
    ИНАЧЕ ЕСЛИ НЕ РаспарситьДату(Ввод) ТО
        Вывести("Неверный формат даты")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    Ввод("Срок годности: ")
    ЕСЛИ НЕ РаспарситьДату(Ввод) ТО
        Вывести("Неверный формат даты")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    Ввод("Количество: ")
    ЕСЛИ СтрокаПуста(Ввод) ТО
        количество := категория.DefaultQuantity ИЛИ 1
    ИНАЧЕ ЕСЛИ НЕ РаспарситьЧисло(Ввод) ТО
        Вывести("Неверное количество")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    Ввод("Единицы измерения: ")
    единицы := ЕСЛИ СтрокаПуста(Ввод) ТО категория.DefaultUnit ИЛИ "шт" ИНАЧЕ ОбрезатьПробелы(Ввод)
    Ввод("Минимальное количество: ")
    ЕСЛИ СтрокаПуста(Ввод) ТО
        минКоличество := категория.DefaultMinQuantity ИЛИ 1
    ИНАЧЕ ЕСЛИ НЕ РаспарситьЧисло(Ввод) ТО
        Вывести("Неверное количество")
        Пауза()
        ВЫХОД
    КОНЕЦ ЕСЛИ
    ресурс := СоздатьРесурс(категория.Id, название, датаПокупки, срокГодности, количество, единицы, минКоличество)
    СохранитьРесурс(ресурс)
    Вывести("Ресурс добавлен")
    Пауза()
КОНЕЦ
```

==== 3.3.5 Алгоритм вывода дерева категорий с подсчётом ресурсов

Формирует иерархическое дерево категорий с рекурсивным подсчётом общего количества ресурсов в каждой категории (включая подкатегории).

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: ShowCategories]) --> GetData[Получить категории и ресурсы]
    GetData --> CountDict[Создать словарь: категория -> количество ресурсов]
    CountDict --> GroupByParent[Сгруппировать категории по ParentId]
    GroupByParent --> CheckEmpty{Категорий = 0?}
    CheckEmpty -->|Да| MsgEmpty[Вывести: 'Категорий пока нет']
    CheckEmpty -->|Нет| DefineRecursive[Определить функцию GetTotalCount]
    MsgEmpty --> Pause1[Пауза]
    Pause1 --> End([Конец])
    DefineRecursive --> CallPrintTree[Вызвать PrintTree с rootKey=0]
    CallPrintTree --> Pause2[Пауза]
    Pause2 --> End
    
    subgraph GetTotalCount[Функция GetTotalCount]
        GTCStart([Вход: categoryId]) --> GetDirect[Получить прямое количество]
        GetDirect --> CheckChildren{Есть подкатегории?}
        CheckChildren -->|Да| LoopChildren[Для каждой подкатегории]
        LoopChildren --> RecursiveCall[GetTotalCount подкатегории]
        RecursiveCall --> AddToTotal[Добавить к общему количеству]
        AddToTotal --> LoopChildren
        CheckChildren -->|Нет| ReturnTotal[Вернуть total]
        AddToTotal --> ReturnTotal
        ReturnTotal --> GTCEnd([Конец])
    end
    
    subgraph PrintTree[Функция PrintTree]
        PTStart([Вход: parentId, prefix, isRootLevel]) --> CheckHasChildren{Есть дочерние категории?}
        CheckHasChildren -->|Нет| PTEnd([Конец])
        CheckHasChildren -->|Да| LoopCat[Для каждой категории]
        LoopCat --> GetTotal[Вызвать GetTotalCount]
        GetTotal --> CheckRoot{isRootLevel?}
        CheckRoot -->|Да| PrintRoot[Вывести: '| Название (количество)']
        CheckRoot -->|Нет| PrintChild[Вывести: 'prefix- Название (количество)']
        PrintRoot --> RecursivePrint[PrintTree с новым prefix]
        PrintChild --> RecursivePrint
        RecursivePrint --> LoopCat
        LoopCat --> PTEnd
    end
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ПоказатьКатегории
НАЧАЛО
    категории := ПолучитьВсеКатегории()
    ресурсы := ПолучитьВсеРесурсы()
    словарьКоличеств := Сгруппировать(ресурсы, CategoryId) -> Подсчитать()
    ЕСЛИ категории.Count = 0 ТО
        Вывести("Категорий пока нет")
    ИНАЧЕ
        поРодителю := Сгруппировать(категории, ParentId ИЛИ 0)
        Вызвать PrintTree(0, "| ", ИСТИНА)
    КОНЕЦ ЕСЛИ
    Пауза()
КОНЕЦ

ФУНКЦИЯ GetTotalCount(categoryId: ЦЕЛОЕ) -> ЦЕЛОЕ
НАЧАЛО
    прямоеКоличество := словарьКоличеств[categoryId] ИЛИ 0
    общее := прямоеКоличество
    ЕСЛИ поРодителю[categoryId] существует ТО
        ДЛЯ КАЖДОЙ подкатегория В поРодителю[categoryId]
            общее := общее + GetTotalCount(подкатегория.Id)
        КОНЕЦ ДЛЯ
    КОНЕЦ ЕСЛИ
    ВЕРНУТЬ общее
КОНЕЦ

ФУНКЦИЯ PrintTree(parentId: ЦЕЛОЕ, prefix: СТРОКА, isRootLevel: ЛОГИЧЕСКОЕ)
НАЧАЛО
    ЕСЛИ поРодителю[parentId] не существует ТО
        ВЫХОД
    КОНЕЦ ЕСЛИ
    ДЛЯ КАЖДОЙ категория В поРодителю[parentId]
        общееКоличество := GetTotalCount(категория.Id)
        ЕСЛИ isRootLevel ТО
            Вывести("| " + категория.Name + " (" + общееКоличество + ")")
        ИНАЧЕ
            Вывести(prefix + "- " + категория.Name + " (" + общееКоличество + ")")
        КОНЕЦ ЕСЛИ
        Вызвать PrintTree(категория.Id, prefix + "  ", ЛОЖЬ)
    КОНЕЦ ДЛЯ
КОНЕЦ
```

==== 3.3.6 Алгоритм инициализации базы данных

Создаёт структуру базы данных при первом запуске программы, если таблицы отсутствуют.

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: EnsureCreated]) --> CreateConn[Создать подключение к БД]
    CreateConn --> OpenConn[Открыть подключение]
    OpenConn --> CreateCmd1[Создать команду для таблицы Categories]
    CreateCmd1 --> SetSQL1[Установить SQL: CREATE TABLE IF NOT EXISTS Categories]
    SetSQL1 --> Execute1[Выполнить команду]
    Execute1 --> CreateCmd2[Создать команду для таблицы Resources]
    CreateCmd2 --> SetSQL2[Установить SQL: CREATE TABLE IF NOT EXISTS Resources]
    SetSQL2 --> Execute2[Выполнить команду]
    Execute2 --> CloseConn[Закрыть подключение]
    CloseConn --> End([Конец])
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ИнициализироватьБазуДанных
НАЧАЛО
    строкаПодключения := "Data Source=expiryspy.db"
    подключение := СоздатьПодключение(строкаПодключения)
    ОткрытьПодключение(подключение)
    команда1 := СоздатьКоманду(подключение)
    команда1.Текст := "CREATE TABLE IF NOT EXISTS Categories (
        Id INTEGER PRIMARY KEY AUTOINCREMENT,
        Name TEXT NOT NULL,
        ParentId INTEGER NULL,
        DefaultQuantity REAL NULL,
        DefaultUnit TEXT NULL,
        DefaultMinQuantity REAL NULL,
        FOREIGN KEY (ParentId) REFERENCES Categories(Id)
    )"
    ВыполнитьКоманду(команда1)
    команда2 := СоздатьКоманду(подключение)
    команда2.Текст := "CREATE TABLE IF NOT EXISTS Resources (
        Id INTEGER PRIMARY KEY AUTOINCREMENT,
        CategoryId INTEGER NOT NULL,
        Name TEXT NOT NULL,
        PurchaseDate TEXT NOT NULL,
        ExpiryDate TEXT NOT NULL,
        Quantity REAL NOT NULL,
        Unit TEXT NOT NULL,
        MinQuantity REAL NOT NULL,
        FOREIGN KEY (CategoryId) REFERENCES Categories(Id)
    )"
    ВыполнитьКоманду(команда2)
    ЗакрытьПодключение(подключение)
КОНЕЦ
```

==== 3.3.7 Алгоритм поиска ресурсов по состоянию

Находит все ресурсы, находящиеся в заданном состоянии (просроченные, скоро истекающие или доступные).

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: GetResourcesByState]) --> Input[Вход: state, now]
    Input --> GetAll[Получить все ресурсы из БД]
    GetAll --> InitList[Инициализировать пустой список результатов]
    InitList --> LoopStart[Для каждого ресурса]
    LoopStart --> GetState[Вызвать GetState ресурса с параметром now]
    GetState --> Compare{Состояние = state?}
    Compare -->|Да| AddToList[Добавить ресурс в список результатов]
    Compare -->|Нет| Next[Следующий ресурс]
    AddToList --> Next
    Next --> CheckMore{Есть ещё ресурсы?}
    CheckMore -->|Да| LoopStart
    CheckMore -->|Нет| ReturnList[Вернуть список результатов]
    ReturnList --> End([Конец])
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ НайтиРесурсыПоСостоянию
ВХОД: state (требуемое состояние), now (текущая дата)
ВЫХОД: Список<ResourceItem>
НАЧАЛО
    всеРесурсы := ПолучитьВсеРесурсы()
    результаты := ПустойСписок()
    ДЛЯ КАЖДОГО ресурс В всеРесурсы
        текущееСостояние := ресурс.GetState(now)
        ЕСЛИ текущееСостояние = state ТО
            Добавить(результаты, ресурс)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ
    ВЕРНУТЬ результаты
КОНЕЦ
```

==== 3.3.8 Алгоритм формирования сводной информации

Формирует обзорную информацию о состоянии всех категорий и ресурсов в системе.

**Блок-схема алгоритма:**

```mermaid
flowchart TD
    Start([Начало: ShowOverview]) --> GetData[Получить категории и ресурсы]
    GetData --> CheckCatEmpty{Категорий = 0?}
    CheckCatEmpty -->|Да| MsgCatEmpty[Вывести: 'Категорий пока нет']
    CheckCatEmpty -->|Нет| GroupCat[Сгруппировать категории по ParentId]
    MsgCatEmpty --> CheckResEmpty
    GroupCat --> CountCat[Подсчитать ресурсы по категориям]
    CountCat --> PrintCatTable[Вывести таблицу категорий]
    PrintCatTable --> CheckResEmpty{Ресурсов = 0?}
    CheckResEmpty -->|Да| MsgResEmpty[Вывести: 'Ресурсов пока нет']
    CheckResEmpty -->|Нет| CalcStats[Вычислить статистику]
    MsgResEmpty --> End([Конец])
    CalcStats --> CountTotal[Подсчитать: всего, просроченных, скоро истекающих, доступных, с малым остатком]
    CountTotal --> PrintResTable[Вывести таблицу состояния ресурсов]
    PrintResTable --> End
```

**Псевдокод алгоритма:**

```
АЛГОРИТМ ПоказатьСводку
НАЧАЛО
    Вывести("=== ExpirySpy ===")
    категории := ПолучитьВсеКатегории()
    ресурсы := ПолучитьВсеРесурсы()
    Вывести("Родительские категории:")
    ЕСЛИ категории.Count = 0 ТО
        Вывести("Категорий пока нет")
    ИНАЧЕ
        поРодителю := Сгруппировать(категории, ParentId ИЛИ 0)
        прямыеКоличества := Сгруппировать(ресурсы, CategoryId) -> Подсчитать()
        ВывестиЗаголовокТаблицы("Категория", "Ресурсов")
        ДЛЯ КАЖДОЙ корневаяКатегория В поРодителю[0]
            общееКоличество := ПодсчитатьРекурсивно(корневаяКатегория.Id)
            ВывестиСтрокуТаблицы(корневаяКатегория.Name, общееКоличество)
        КОНЕЦ ДЛЯ
    КОНЕЦ ЕСЛИ
    Вывести("Общее состояние ресурсов:")
    ЕСЛИ ресурсы.Count = 0 ТО
        Вывести("Ресурсов пока нет")
    ИНАЧЕ
        сейчас := ТекущаяДата()
        всего := ресурсы.Count
        просрочено := Подсчитать(ресурсы, где GetState(сейчас) = Expired)
        скоро := Подсчитать(ресурсы, где GetState(сейчас) = ExpiringSoon)
        доступно := Подсчитать(ресурсы, где GetState(сейчас) = Available)
        мало := Подсчитать(ресурсы, где IsLowOnStock() = ИСТИНА)
        ВывестиЗаголовокТаблицы("Состояние", "Кол-во")
        ВывестиСтрокуТаблицы("Всего", всего)
        ВывестиСтрокуТаблицы("Просрочены", просрочено)
        ВывестиСтрокуТаблицы("Скоро истечёт", скоро)
        ВывестиСтрокуТаблицы("Доступны", доступно)
        ВывестиСтрокуТаблицы("Мало на складе", мало)
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

Все алгоритмы реализованы с учётом обработки ошибочных ситуаций и валидации входных данных, что обеспечивает надёжность работы программы и корректность хранимых данных.




